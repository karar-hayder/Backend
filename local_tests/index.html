<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WebSocket UploadStatusConsumer Tester</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      background: #f5f5f7;
      color: #1d1d1f;
      line-height: 1.6;
      padding: 20px;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
      display: grid;
      grid-template-columns: 400px 1fr;
      gap: 20px;
    }

    .panel {
      background: white;
      border-radius: 12px;
      padding: 24px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }

    .panel h2 {
      font-size: 20px;
      margin-bottom: 16px;
      color: #1d1d1f;
      border-bottom: 2px solid #f5f5f7;
      padding-bottom: 8px;
    }

    .panel h3 {
      font-size: 16px;
      margin: 16px 0 8px 0;
      color: #424245;
    }

    .form-group {
      margin-bottom: 16px;
    }

    label {
      display: block;
      font-size: 14px;
      font-weight: 500;
      margin-bottom: 6px;
      color: #424245;
    }

    input[type="text"],
    input[type="password"],
    select,
    textarea {
      width: 100%;
      padding: 10px 12px;
      border: 1px solid #d2d2d7;
      border-radius: 8px;
      font-size: 14px;
      font-family: inherit;
      transition: border-color 0.2s;
    }

    input:focus,
    select:focus,
    textarea:focus {
      outline: none;
      border-color: #0071e3;
    }

    textarea {
      resize: vertical;
      font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', monospace;
      font-size: 13px;
    }

    button {
      background: #0071e3;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: background 0.2s;
      width: 100%;
    }

    button:hover:not(:disabled) {
      background: #0077ed;
    }

    button:disabled {
      background: #d2d2d7;
      cursor: not-allowed;
    }

    button.secondary {
      background: #f5f5f7;
      color: #1d1d1f;
    }

    button.secondary:hover:not(:disabled) {
      background: #e8e8ed;
    }

    button.danger {
      background: #ff3b30;
    }

    button.danger:hover:not(:disabled) {
      background: #ff453a;
    }

    .status-indicator {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 8px 12px;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 500;
      margin-bottom: 16px;
    }

    .status-indicator::before {
      content: '';
      width: 10px;
      height: 10px;
      border-radius: 50%;
      display: inline-block;
    }

    .status-connected {
      background: #e6f7e6;
      color: #1a7f1a;
    }

    .status-connected::before {
      background: #1a7f1a;
      animation: pulse 2s infinite;
    }

    .status-disconnected {
      background: #ffe6e6;
      color: #d11a1a;
    }

    .status-disconnected::before {
      background: #d11a1a;
    }

    .status-connecting {
      background: #fff4e6;
      color: #d97706;
    }

    .status-connecting::before {
      background: #d97706;
      animation: pulse 1s infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    .message-log {
      height: 600px;
      overflow-y: auto;
      background: #1d1d1f;
      border-radius: 8px;
      padding: 16px;
      font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', monospace;
      font-size: 13px;
    }

    .message-entry {
      margin-bottom: 12px;
      padding: 10px;
      border-radius: 6px;
      border-left: 3px solid transparent;
    }

    .message-entry.sent {
      background: rgba(0, 113, 227, 0.1);
      border-left-color: #0071e3;
    }

    .message-entry.received {
      background: rgba(26, 127, 26, 0.1);
      border-left-color: #1a7f1a;
    }

    .message-entry.error {
      background: rgba(255, 59, 48, 0.1);
      border-left-color: #ff3b30;
    }

    .message-entry.info {
      background: rgba(255, 255, 255, 0.05);
      border-left-color: #d2d2d7;
    }

    .message-time {
      color: #86868b;
      font-size: 11px;
      margin-bottom: 4px;
    }

    .message-content {
      color: #f5f5f7;
      white-space: pre-wrap;
      word-break: break-word;
    }

    .message-content code {
      background: rgba(255, 255, 255, 0.1);
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 12px;
    }

    .stats {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 12px;
      margin-bottom: 16px;
    }

    .stat-item {
      background: #f5f5f7;
      padding: 12px;
      border-radius: 8px;
      text-align: center;
    }

    .stat-value {
      font-size: 24px;
      font-weight: 600;
      color: #0071e3;
    }

    .stat-label {
      font-size: 12px;
      color: #86868b;
      margin-top: 4px;
    }

    .button-group {
      display: flex;
      gap: 8px;
    }

    .button-group button {
      flex: 1;
    }

    .preset-buttons {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 8px;
      margin-top: 12px;
    }

    .preset-buttons button {
      font-size: 12px;
      padding: 8px 12px;
    }

    .token-input-group {
      position: relative;
    }

    .token-toggle {
      position: absolute;
      right: 8px;
      top: 50%;
      transform: translateY(-50%);
      background: transparent;
      border: none;
      color: #86868b;
      cursor: pointer;
      padding: 4px 8px;
      font-size: 12px;
      width: auto;
    }

    .token-toggle:hover {
      color: #1d1d1f;
    }

    .help-text {
      font-size: 12px;
      color: #86868b;
      margin-top: 4px;
    }

    .checkbox-group {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .checkbox-group input[type="checkbox"] {
      width: auto;
    }

    input[type="file"] {
      padding: 8px;
      border: 1px dashed #d2d2d7;
      background: #f5f5f7;
      cursor: pointer;
    }

    input[type="file"]:hover {
      border-color: #0071e3;
      background: #e8f4fd;
    }

    #fileInfo {
      padding: 8px;
      border-radius: 6px;
      background: #f5f5f7;
      font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', monospace;
    }

    .log-controls {
      display: flex;
      gap: 8px;
      margin-bottom: 12px;
    }

    .log-controls button {
      flex: 1;
      padding: 8px;
      font-size: 12px;
    }

    @media (max-width: 1024px) {
      .container {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <!-- Left Panel: Controls -->
    <div>
      <!-- Connection Panel -->
      <div class="panel">
        <h2>Connection</h2>
        <div id="statusIndicator" class="status-indicator status-disconnected">
          Disconnected
        </div>
        
        <div class="form-group">
          <label for="serverUrl">Server URL</label>
          <input type="text" id="serverUrl" value="localhost:8000" placeholder="localhost:8000">
          <div class="help-text">WebSocket server host and port</div>
        </div>

        <div class="form-group">
          <label for="instanceId">Instance ID (Optional)</label>
          <input type="text" id="instanceId" placeholder="UUID for specific instance">
          <div class="help-text">Leave blank to connect to 'all' group</div>
        </div>

        <div class="form-group">
          <label for="accessToken">Access Token</label>
          <div class="token-input-group">
            <input type="password" id="accessToken" placeholder="JWT access token">
            <button type="button" class="token-toggle" id="tokenToggle">Show</button>
          </div>
          <div class="help-text">JWT token for authentication</div>
        </div>

        <div class="form-group checkbox-group">
          <input type="checkbox" id="autoReconnect">
          <label for="autoReconnect" style="margin: 0;">Auto-reconnect on disconnect</label>
        </div>

        <div class="button-group">
          <button id="connectBtn">Connect</button>
          <button id="disconnectBtn" class="secondary" disabled>Disconnect</button>
        </div>
      </div>

      <!-- Command Panel -->
      <div class="panel" style="margin-top: 20px;">
        <h2>Send Command</h2>
        
        <div class="form-group">
          <label for="commandType">Command Type</label>
          <select id="commandType">
            <option value="subscribe">Subscribe</option>
            <option value="retrieve">Retrieve</option>
            <option value="list">List</option>
            <option value="create">Create</option>
            <option value="update">Update</option>
            <option value="delete">Delete</option>
          </select>
        </div>

        <div class="form-group" id="commandInstanceGroup">
          <label for="commandInstanceId">Instance ID</label>
          <input type="text" id="commandInstanceId" placeholder="UUID (optional)">
        </div>

        <div class="form-group" id="fileUploadGroup" style="display: none;">
          <label for="imageFile">Upload Image File</label>
          <input type="file" id="imageFile" accept="image/*">
          <div class="help-text">Select an image file to upload (will be converted to base64)</div>
          <div id="fileInfo" style="margin-top: 8px; font-size: 12px; color: #86868b;"></div>
        </div>

        <div class="form-group" id="commandDataGroup">
          <label for="commandData">Data (JSON)</label>
          <textarea id="commandData" rows="6" placeholder='{"image_path": "path/to/image.png"} or use file upload above'></textarea>
          <div class="help-text">For create: Use file upload above OR provide image_path (server-side) OR image_base64</div>
        </div>

        <button id="sendBtn" disabled>Send Command</button>

        <h3>Quick Presets</h3>
        <div class="preset-buttons">
          <button class="secondary" onclick="loadPreset('subscribe')">Subscribe</button>
          <button class="secondary" onclick="loadPreset('list')">List All</button>
          <button class="secondary" onclick="loadPreset('create')">Create Example</button>
          <button class="secondary" onclick="loadPreset('update')">Update Example</button>
        </div>
      </div>

      <!-- Statistics Panel -->
      <div class="panel" style="margin-top: 20px;">
        <h2>Statistics</h2>
        <div class="stats">
          <div class="stat-item">
            <div class="stat-value" id="statSent">0</div>
            <div class="stat-label">Sent</div>
          </div>
          <div class="stat-item">
            <div class="stat-value" id="statReceived">0</div>
            <div class="stat-label">Received</div>
          </div>
          <div class="stat-item">
            <div class="stat-value" id="statErrors">0</div>
            <div class="stat-label">Errors</div>
          </div>
        </div>
      </div>
    </div>

    <!-- Right Panel: Message Log -->
    <div>
      <div class="panel">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
          <h2 style="margin: 0;">Message Log</h2>
          <div class="log-controls">
            <button class="secondary" id="clearLogBtn">Clear</button>
            <button class="secondary" id="exportLogBtn">Export</button>
          </div>
        </div>
        <div class="message-log" id="messageLog"></div>
      </div>
    </div>
  </div>

  <script>
    // Global error handler to prevent page refresh on unhandled errors
    window.addEventListener('error', (event) => {
      console.error('Global error:', event.error);
      event.preventDefault();
      return false;
    });
    
    window.addEventListener('unhandledrejection', (event) => {
      console.error('Unhandled promise rejection:', event.reason);
      event.preventDefault();
    });

    // State
    let ws = null;
    let reconnectTimer = null;
    let stats = { sent: 0, received: 0, errors: 0 };
    let messageHistory = [];

    // DOM Elements
    const statusIndicator = document.getElementById('statusIndicator');
    const serverUrlInput = document.getElementById('serverUrl');
    const instanceIdInput = document.getElementById('instanceId');
    const accessTokenInput = document.getElementById('accessToken');
    const tokenToggle = document.getElementById('tokenToggle');
    const autoReconnectCheck = document.getElementById('autoReconnect');
    const connectBtn = document.getElementById('connectBtn');
    const disconnectBtn = document.getElementById('disconnectBtn');
    const commandTypeSelect = document.getElementById('commandType');
    const commandInstanceGroup = document.getElementById('commandInstanceGroup');
    const commandInstanceIdInput = document.getElementById('commandInstanceId');
    const commandDataGroup = document.getElementById('commandDataGroup');
    const commandDataTextarea = document.getElementById('commandData');
    const fileUploadGroup = document.getElementById('fileUploadGroup');
    const imageFileInput = document.getElementById('imageFile');
    const fileInfo = document.getElementById('fileInfo');
    const sendBtn = document.getElementById('sendBtn');
    const messageLog = document.getElementById('messageLog');
    const clearLogBtn = document.getElementById('clearLogBtn');
    const exportLogBtn = document.getElementById('exportLogBtn');

    // Load token from localStorage
    const savedToken = localStorage.getItem('ws_access_token');
    if (savedToken) {
      accessTokenInput.value = savedToken;
    }

    // Token visibility toggle
    tokenToggle.addEventListener('click', () => {
      const isPassword = accessTokenInput.type === 'password';
      accessTokenInput.type = isPassword ? 'text' : 'password';
      tokenToggle.textContent = isPassword ? 'Hide' : 'Show';
    });

    // File input handler
    imageFileInput.addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (!file) {
        fileInfo.textContent = '';
        return;
      }

      if (!file.type.startsWith('image/')) {
        fileInfo.textContent = 'âš ï¸ Please select an image file';
        fileInfo.style.color = '#ff3b30';
        return;
      }

      fileInfo.textContent = `ðŸ“Ž ${file.name} (${(file.size / 1024).toFixed(2)} KB) - Converting...`;
      fileInfo.style.color = '#86868b';

      try {
        const base64 = await fileToBase64(file);
        // Store base64 for use when sending
        imageFileInput.dataset.base64 = base64;
        fileInfo.textContent = `âœ… ${file.name} (${(file.size / 1024).toFixed(2)} KB) - Ready to upload`;
        fileInfo.style.color = '#1a7f1a';
      } catch (error) {
        fileInfo.textContent = `âŒ Error reading file: ${error.message}`;
        fileInfo.style.color = '#ff3b30';
      }
    });

    // Helper function to convert file to base64
    function fileToBase64(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => {
          const result = reader.result;
          // Remove data URL prefix if present
          const base64 = result.includes(',') ? result.split(',')[1] : result;
          resolve(base64);
        };
        reader.onerror = reject;
        reader.readAsDataURL(file);
      });
    }

    // Command type change handler
    commandTypeSelect.addEventListener('change', () => {
      const type = commandTypeSelect.value;
      const needsData = ['create', 'update'].includes(type);
      const needsInstanceId = type !== 'list';
      const isCreate = type === 'create';
      
      commandDataGroup.style.display = needsData ? 'block' : 'none';
      fileUploadGroup.style.display = isCreate ? 'block' : 'none';
      commandInstanceGroup.style.display = needsInstanceId ? 'block' : 'none';
      
      if (!needsData) {
        commandDataTextarea.value = '';
      }
      
      // Clear file input when switching away from create
      if (!isCreate) {
        imageFileInput.value = '';
        imageFileInput.dataset.base64 = '';
        fileInfo.textContent = '';
      }
      
      // Update placeholder
      if (type === 'create') {
        commandDataTextarea.placeholder = '{"image_path": "path/to/image.png"} or use file upload above';
      } else if (type === 'update') {
        commandDataTextarea.placeholder = '{"status": "processed", "processed_text": "..."}';
      }
    });

    // Initialize command UI
    commandTypeSelect.dispatchEvent(new Event('change'));

    // Logging functions
    function logMessage(type, content, data = null) {
      const timestamp = new Date().toLocaleTimeString();
      const entry = { type, content, data, timestamp };
      messageHistory.push(entry);

      const entryDiv = document.createElement('div');
      entryDiv.className = `message-entry ${type}`;
      
      const timeDiv = document.createElement('div');
      timeDiv.className = 'message-time';
      timeDiv.textContent = timestamp;
      entryDiv.appendChild(timeDiv);

      const contentDiv = document.createElement('div');
      contentDiv.className = 'message-content';
      
      if (data) {
        contentDiv.textContent = `${content}\n${JSON.stringify(data, null, 2)}`;
      } else {
        contentDiv.textContent = content;
      }
      
      entryDiv.appendChild(contentDiv);
      messageLog.appendChild(entryDiv);
      messageLog.scrollTop = messageLog.scrollHeight;

      // Update stats
      if (type === 'sent') stats.sent++;
      else if (type === 'received') stats.received++;
      else if (type === 'error') stats.errors++;
      updateStats();
    }

    function updateStats() {
      document.getElementById('statSent').textContent = stats.sent;
      document.getElementById('statReceived').textContent = stats.received;
      document.getElementById('statErrors').textContent = stats.errors;
    }

    function updateStatus(status, text) {
      statusIndicator.className = `status-indicator status-${status}`;
      statusIndicator.textContent = text;
    }

    // WebSocket functions
    function getWebSocketURL() {
      const serverUrl = serverUrlInput.value.trim() || 'localhost:8000';
      const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
      const instanceId = instanceIdInput.value.trim();
      
      if (instanceId) {
        return `${protocol}//${serverUrl}/ws/core/upload/${instanceId}/`;
      }
      return `${protocol}//${serverUrl}/ws/core/upload/`;
    }

    function connect() {
      if (ws && ws.readyState === WebSocket.OPEN) {
        logMessage('info', 'Already connected');
        return;
      }

      const url = getWebSocketURL();
      const token = accessTokenInput.value.trim();
      
      if (!token) {
        logMessage('error', 'Access token is required');
        return;
      }

      // Save token to localStorage
      localStorage.setItem('ws_access_token', token);

      const fullUrl = `${url}?token=${encodeURIComponent(token)}`;
      
      updateStatus('connecting', 'Connecting...');
      connectBtn.disabled = true;
      disconnectBtn.disabled = false;

      logMessage('info', `Connecting to ${url.replace(/token=[^&]*/, 'token=***')}`);

      try {
        ws = new WebSocket(fullUrl);

        ws.onopen = () => {
          updateStatus('connected', 'Connected');
          logMessage('info', 'WebSocket connected successfully');
          sendBtn.disabled = false;
        };

        ws.onclose = (event) => {
          updateStatus('disconnected', 'Disconnected');
          connectBtn.disabled = false;
          disconnectBtn.disabled = true;
          sendBtn.disabled = true;
          
          logMessage('info', `Disconnected (code: ${event.code}, reason: ${event.reason || 'none'})`);
          
          // Don't auto-reconnect if it was a normal closure (code 1000)
          // or if user manually disconnected
          if (autoReconnectCheck.checked && event.code !== 1000 && event.code !== 1001) {
            logMessage('info', 'Auto-reconnecting in 3 seconds...');
            reconnectTimer = setTimeout(connect, 3000);
          }
        };

        ws.onerror = (error) => {
          updateStatus('disconnected', 'Error');
          logMessage('error', 'WebSocket error occurred', error);
          // Prevent page refresh on error
          event?.preventDefault?.();
        };

        ws.onmessage = (event) => {
          try {
            const data = JSON.parse(event.data);
            logMessage('received', 'Message received', data);
          } catch (e) {
            logMessage('received', 'Non-JSON message received', event.data);
          }
        };
      } catch (error) {
        updateStatus('disconnected', 'Connection Failed');
        logMessage('error', 'Failed to create WebSocket', error);
        connectBtn.disabled = false;
        disconnectBtn.disabled = true;
      }
    }

    function disconnect() {
      if (reconnectTimer) {
        clearTimeout(reconnectTimer);
        reconnectTimer = null;
      }
      
      if (ws) {
        ws.close(1000, 'User disconnected');
        ws = null;
      }
    }

    function sendCommand() {
      if (!ws || ws.readyState !== WebSocket.OPEN) {
        logMessage('error', 'WebSocket is not connected');
        return;
      }

      const type = commandTypeSelect.value;
      const instanceId = commandInstanceIdInput.value.trim();
      const dataStr = commandDataTextarea.value.trim();

      const message = { type };

      if (instanceId && type !== 'list') {
        message.instance_id = instanceId;
      }

      if (['create', 'update'].includes(type)) {
        let data = {};
        
        // If file is uploaded, use base64
        if (type === 'create' && imageFileInput.dataset.base64) {
          data.image_base64 = imageFileInput.dataset.base64;
          logMessage('info', `Using uploaded file: ${imageFileInput.files[0]?.name || 'unknown'}`);
        }
        
        // Merge with JSON data if provided
        if (dataStr) {
          try {
            const jsonData = JSON.parse(dataStr);
            data = { ...data, ...jsonData };
          } catch (e) {
            logMessage('error', 'Invalid JSON in data field', e.message);
            return;
          }
        }
        
        message.data = data;
      }

      try {
        // Don't log the full base64 data (too large)
        const logMessage_data = { ...message };
        if (logMessage_data.data && logMessage_data.data.image_base64) {
          logMessage_data.data = {
            ...logMessage_data.data,
            image_base64: `[base64 data: ${logMessage_data.data.image_base64.length} chars]`
          };
        }
        logMessage('sent', `Command: ${type}`, logMessage_data);
        
        ws.send(JSON.stringify(message));
      } catch (error) {
        logMessage('error', 'Failed to send message', error);
      }
    }

    // Preset functions
    function loadPreset(preset) {
      // Clear file input when loading presets
      imageFileInput.value = '';
      imageFileInput.dataset.base64 = '';
      fileInfo.textContent = '';
      
      switch (preset) {
        case 'subscribe':
          commandTypeSelect.value = 'subscribe';
          commandTypeSelect.dispatchEvent(new Event('change'));
          break;
        case 'list':
          commandTypeSelect.value = 'list';
          commandTypeSelect.dispatchEvent(new Event('change'));
          break;
        case 'create':
          commandTypeSelect.value = 'create';
          commandDataTextarea.value = ''; // Let user choose: file upload or JSON
          commandTypeSelect.dispatchEvent(new Event('change'));
          break;
        case 'update':
          commandTypeSelect.value = 'update';
          commandDataTextarea.value = JSON.stringify({
            status: 'processed',
            processed_text: 'Sample processed text'
          }, null, 2);
          commandTypeSelect.dispatchEvent(new Event('change'));
          break;
      }
    }

    // Event listeners
    connectBtn.addEventListener('click', connect);
    disconnectBtn.addEventListener('click', disconnect);
    sendBtn.addEventListener('click', sendCommand);
    
    clearLogBtn.addEventListener('click', () => {
      messageLog.innerHTML = '';
      messageHistory = [];
      stats = { sent: 0, received: 0, errors: 0 };
      updateStats();
    });

    exportLogBtn.addEventListener('click', () => {
      const logData = {
        timestamp: new Date().toISOString(),
        stats,
        messages: messageHistory
      };
      const blob = new Blob([JSON.stringify(logData, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `websocket-log-${Date.now()}.json`;
      a.click();
      URL.revokeObjectURL(url);
    });

    // Allow Enter key to send command
    commandDataTextarea.addEventListener('keydown', (e) => {
      if (e.ctrlKey && e.key === 'Enter') {
        sendCommand();
      }
    });

    // Initialize
    updateStats();
  </script>
</body>
</html>