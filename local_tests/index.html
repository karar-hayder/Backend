<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WebSocket UploadStatusConsumer Tester</title>
  <link rel="stylesheet" href="index.css">
</head>
<body>
  <div class="container">
    <!-- Left Panel: Controls -->
    <div>
      <!-- Connection Panel -->
      <div class="panel">
        <h2>Connection</h2>
        <div id="statusIndicator" class="status-indicator status-disconnected">
          Disconnected
        </div>
        
        <div class="form-group">
          <label for="serverUrl">Server URL</label>
          <input type="text" id="serverUrl" value="localhost:8000" placeholder="localhost:8000">
          <div class="help-text">WebSocket server host and port</div>
        </div>

        <div class="form-group">
          <label for="accessToken">Access Token</label>
          <div class="token-input-group">
            <input type="password" id="accessToken" placeholder="JWT access token">
            <button type="button" class="token-toggle" id="tokenToggle">Show</button>
          </div>
          <div class="help-text">JWT token for authentication</div>
        </div>

        <div class="form-group checkbox-group">
          <input type="checkbox" id="autoReconnect">
          <label for="autoReconnect" style="margin: 0;">Auto-reconnect on disconnect</label>
        </div>

        <div class="button-group">
          <button id="connectBtn">Connect</button>
          <button id="disconnectBtn" class="secondary" disabled>Disconnect</button>
        </div>
      </div>

      <!-- Command Panel -->
      <div class="panel" style="margin-top: 20px;">
        <h2>Send Command</h2>
        
        <div class="form-group">
          <label for="commandType">Command Type</label>
          <select id="commandType">
            <option value="subscribe">Subscribe</option>
            <option value="retrieve">Retrieve</option>
            <option value="list">List</option>
            <option value="create">Create</option>
            <option value="update">Update</option>
            <option value="delete">Delete</option>
          </select>
        </div>

        <div class="form-group" id="commandInstanceGroup">
          <label for="commandInstanceId">Instance ID</label>
          <input type="text" id="commandInstanceId" placeholder="UUID">
        </div>

        <div class="form-group" id="fileUploadGroup" style="display: none;">
          <label for="imageFile">Upload Image File</label>
          <input type="file" id="imageFile" accept="image/*">
          <div class="help-text">Select an image file to upload (will be converted to base64)</div>
          <div id="fileInfo" style="margin-top: 8px; font-size: 12px; color: #86868b;"></div>
        </div>

        <div class="form-group" id="commandDataGroup">
          <label for="commandData">Data (JSON)</label>
          <textarea id="commandData" rows="6" placeholder='{"image_path": "path/to/image.png"} or use file upload above'></textarea>
          <div class="help-text">For create: Use file upload above OR provide image_path (server-side) OR image_base64</div>
        </div>

        <button id="sendBtn" disabled>Send Command</button>

        <h3>Quick Presets</h3>
        <div class="preset-buttons">
          <button class="secondary" onclick="loadPreset('subscribe')">Subscribe</button>
          <button class="secondary" onclick="loadPreset('list')">List All</button>
          <button class="secondary" onclick="loadPreset('create')">Create Example</button>
          <button class="secondary" onclick="loadPreset('update')">Update Example</button>
        </div>
      </div>

      <!-- Statistics Panel -->
      <div class="panel" style="margin-top: 20px;">
        <h2>Statistics</h2>
        <div class="stats">
          <div class="stat-item">
            <div class="stat-value" id="statSent">0</div>
            <div class="stat-label">Sent</div>
          </div>
          <div class="stat-item">
            <div class="stat-value" id="statReceived">0</div>
            <div class="stat-label">Received</div>
          </div>
          <div class="stat-item">
            <div class="stat-value" id="statErrors">0</div>
            <div class="stat-label">Errors</div>
          </div>
        </div>
      </div>
    </div>

    <!-- Right Panel: Message Log -->
    <div>
      <div class="panel">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
          <h2 style="margin: 0;">Message Log</h2>
          <div class="log-controls">
            <button class="secondary" id="clearLogBtn">Clear</button>
            <button class="secondary" id="exportLogBtn">Export</button>
          </div>
        </div>
        <div class="message-log" id="messageLog"></div>
      </div>
    </div>
  </div>
  <script>
    // Prevent page reload on all uncaught errors or promise rejections
    window.addEventListener('error', (event) => {
      event.preventDefault();
      event.stopImmediatePropagation();
      // Custom logging
      console.error('Global error:', event.error ? event.error : event.message);
      return false; // Prevents browser default error handling
    }, true);
    window.addEventListener('unhandledrejection', (event) => {
      event.preventDefault();
      event.stopImmediatePropagation();
      console.error('Unhandled promise rejection:', event.reason);
    }, true);

    // State
    let ws = null;
    let reconnectTimer = null;
    let stats = { sent: 0, received: 0, errors: 0 };
    let messageHistory = [];

    // DOM Elements
    const statusIndicator = document.getElementById('statusIndicator');
    const serverUrlInput = document.getElementById('serverUrl');
    const accessTokenInput = document.getElementById('accessToken');
    const tokenToggle = document.getElementById('tokenToggle');
    const autoReconnectCheck = document.getElementById('autoReconnect');
    const connectBtn = document.getElementById('connectBtn');
    const disconnectBtn = document.getElementById('disconnectBtn');
    const commandTypeSelect = document.getElementById('commandType');
    const commandInstanceGroup = document.getElementById('commandInstanceGroup');
    const commandInstanceIdInput = document.getElementById('commandInstanceId');
    const commandDataGroup = document.getElementById('commandDataGroup');
    const commandDataTextarea = document.getElementById('commandData');
    const fileUploadGroup = document.getElementById('fileUploadGroup');
    const imageFileInput = document.getElementById('imageFile');
    const fileInfo = document.getElementById('fileInfo');
    const sendBtn = document.getElementById('sendBtn');
    const messageLog = document.getElementById('messageLog');
    const clearLogBtn = document.getElementById('clearLogBtn');
    const exportLogBtn = document.getElementById('exportLogBtn');

    // Load token from localStorage
    const savedToken = localStorage.getItem('ws_access_token');
    if (savedToken) {
      accessTokenInput.value = savedToken;
    }

    // Token visibility toggle
    tokenToggle.addEventListener('click', () => {
      const isPassword = accessTokenInput.type === 'password';
      accessTokenInput.type = isPassword ? 'text' : 'password';
      tokenToggle.textContent = isPassword ? 'Hide' : 'Show';
    });

    // File input handler
    imageFileInput.addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (!file) {
        fileInfo.textContent = '';
        return;
      }
      if (!file.type.startsWith('image/')) {
        fileInfo.textContent = 'âš ï¸ Please select an image file';
        fileInfo.style.color = '#ff3b30';
        return;
      }
      fileInfo.textContent = `ðŸ“Ž ${file.name} (${(file.size / 1024).toFixed(2)} KB) - Converting...`;
      fileInfo.style.color = '#86868b';
      try {
        const base64 = await fileToBase64(file);
        imageFileInput.dataset.base64 = base64;
        fileInfo.textContent = `âœ… ${file.name} (${(file.size / 1024).toFixed(2)} KB) - Ready to upload`;
        fileInfo.style.color = '#1a7f1a';
      } catch (error) {
        fileInfo.textContent = `âŒ Error reading file: ${error.message}`;
        fileInfo.style.color = '#ff3b30';
      }
    });

    function fileToBase64(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => {
          const result = reader.result;
          const base64 = result.includes(',') ? result.split(',')[1] : result;
          resolve(base64);
        };
        reader.onerror = reject;
        reader.readAsDataURL(file);
      });
    }

    // Toggle data UI by command type
    commandTypeSelect.addEventListener('change', () => {
      const type = commandTypeSelect.value;
      const needsData = ['create', 'update'].includes(type);
      const isCreate = type === 'create';

      commandDataGroup.style.display = needsData ? 'block' : 'none';
      fileUploadGroup.style.display = isCreate ? 'block' : 'none';
      commandInstanceGroup.style.display = type !== 'list' ? 'block' : 'none';
      if (!needsData) commandDataTextarea.value = '';
      if (!isCreate) {
        imageFileInput.value = '';
        imageFileInput.dataset.base64 = '';
        fileInfo.textContent = '';
      }
      if (type === 'create')
        commandDataTextarea.placeholder = '{"image_path": "path/to/image.png"} or use file upload above';
      else if (type === 'update')
        commandDataTextarea.placeholder = '{"status": "processed", "processed_text": "..."}';
    });
    commandTypeSelect.dispatchEvent(new Event('change'));

    // Logging functions
    function logMessage(type, content, data = null) {
      const timestamp = new Date().toLocaleTimeString();
      const entry = { type, content, data, timestamp };
      messageHistory.push(entry);

      // Also log to console
      if (type === 'error') {
        console.error(`[${timestamp}] [${type}] ${content}`, data || '');
      } else if (type === 'received') {
        console.info(`[${timestamp}] [${type}] ${content}`, data || '');
      } else if (type === 'sent') {
        console.log(`[${timestamp}] [${type}] ${content}`, data || '');
      } else {
        console.debug(`[${timestamp}] [${type}] ${content}`, data || '');
      }

      const entryDiv = document.createElement('div');
      entryDiv.className = `message-entry ${type}`;
      const timeDiv = document.createElement('div');
      timeDiv.className = 'message-time';
      timeDiv.textContent = timestamp;
      entryDiv.appendChild(timeDiv);

      const contentDiv = document.createElement('div');
      contentDiv.className = 'message-content';
      if (data)
        contentDiv.textContent = `${content}\n${JSON.stringify(data, null, 2)}`;
      else
        contentDiv.textContent = content;
      entryDiv.appendChild(contentDiv);
      messageLog.appendChild(entryDiv);
      messageLog.scrollTop = messageLog.scrollHeight;

      if (type === 'sent') stats.sent++;
      else if (type === 'received') stats.received++;
      else if (type === 'error') stats.errors++;
      updateStats();
    }
    function updateStats() {
      document.getElementById('statSent').textContent = stats.sent;
      document.getElementById('statReceived').textContent = stats.received;
      document.getElementById('statErrors').textContent = stats.errors;
    }
    function updateStatus(status, text) {
      statusIndicator.className = `status-indicator status-${status}`;
      statusIndicator.textContent = text;
    }

    // WebSocket functions
    function getWebSocketURL() {
      const serverUrl = serverUrlInput.value.trim() || 'localhost:8000';
      const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
      // All comms through one group: no instanceId in URL!
      return `${protocol}//${serverUrl}/ws/core/upload/`;
    }

    function connect() {
      if (ws && ws.readyState === WebSocket.OPEN) {
        logMessage('info', 'Already connected');
        return;
      }
      const url = getWebSocketURL();
      const token = accessTokenInput.value.trim();
      if (!token) {
        logMessage('error', 'Access token is required');
        return;
      }
      // Save token
      localStorage.setItem('ws_access_token', token);
      const fullUrl = `${url}?token=${encodeURIComponent(token)}`;

      updateStatus('connecting', 'Connecting...');
      connectBtn.disabled = true;
      disconnectBtn.disabled = false;
      logMessage('info', `Connecting to ${url.replace(/token=[^&]*/, 'token=***')}`);

      try {
        ws = new WebSocket(fullUrl);

        ws.onopen = () => {
          updateStatus('connected', 'Connected');
          logMessage('info', 'WebSocket connected successfully');
          sendBtn.disabled = false;
        };

        ws.onclose = (event) => {
          updateStatus('disconnected', 'Disconnected');
          connectBtn.disabled = false;
          disconnectBtn.disabled = true;
          sendBtn.disabled = true;
          logMessage('info', `Disconnected (code: ${event.code}, reason: ${event.reason || 'none'})`);
          if (autoReconnectCheck.checked && event.code !== 1000 && event.code !== 1001) {
            logMessage('info', 'Auto-reconnecting in 3 seconds...');
            reconnectTimer = setTimeout(connect, 3000);
          }
        };

        ws.onerror = (e) => {
          updateStatus('disconnected', 'Error');
          logMessage('error', 'WebSocket error occurred', e);
          // important: prevent default error (page reload)
          if (e && typeof e.preventDefault === "function") e.preventDefault();
        };

        ws.onmessage = (event) => {
          let data;
          let raw = event.data;
          try {
            data = JSON.parse(raw);
          } catch (e) {
            logMessage('received', 'Non-JSON message received', raw);
            return;
          }

          /*
            Support new output shape:
            - For type Upload.list, expect a 'list' field of array of upload objects.
            - Old style: items/instances/objects.
            - Show all items in the log summary for Upload.list type.
          */

          let showType = data.type || '(no type)';
          let lowerType = typeof showType === "string" ? showType.toLowerCase() : "";

          // If message is an error
          if (lowerType === "error") {
            logMessage('error', `[Error] ${(data.message || '')}`, data);
          } else if (lowerType === "heartbeat") {
            logMessage('received', `[Heartbeat]`, data);
          }
          // Upload Created/Updated/Deleted Events
          else if (
            lowerType === "upload.created" ||
            lowerType === "upload.updated" ||
            lowerType === "upload.deleted"
          ) {
            let summary = `${showType}`;
            if (data.instance) summary += `\nInstance: ${JSON.stringify(data.instance, null, 2)}`;
            if (data.object) summary += `\nObject: ${JSON.stringify(data.object, null, 2)}`;
            logMessage('received', summary, data);
          }
          // List responses
          else if (
            lowerType === "upload.list" ||
            lowerType === "list"
          ) {
            // Prefer 'list' field if present (new response shape)
            let items = Array.isArray(data.list) ? data.list :
              (Array.isArray(data.items) ? data.items :
              (Array.isArray(data.instances) ? data.instances :
              (Array.isArray(data.objects) ? data.objects : [])));
            let count = items.length;
            let summary = `List: ${count} item(s)`;
            if (count > 0) {
              summary += "\nFirst: " + JSON.stringify(items[0], null, 2);
            }
            // If there are a lot, also list all IDs
            if (count > 1) {
              summary += "\nIDs:\n" + items.map(i => i.id).join("\n");
            }
            logMessage('received', summary, data);
          }
          // Detail responses
          else if (
            lowerType === "upload.detail" ||
            lowerType === "detail"
          ) {
            let summary = "Detail:";
            let instance = data.instance || data.object || data.detail;
            if (instance) summary += "\n" + JSON.stringify(instance, null, 2);
            logMessage('received', summary, data);
          }
          else {
            logMessage('received', `Message received: ${showType}`, data);
          }
        };
      } catch (error) {
        updateStatus('disconnected', 'Connection Failed');
        logMessage('error', 'Failed to create WebSocket', error);
        connectBtn.disabled = false;
        disconnectBtn.disabled = true;
      }
    }

    function disconnect() {
      if (reconnectTimer) {
        clearTimeout(reconnectTimer);
        reconnectTimer = null;
      }
      if (ws) {
        ws.close(1000, 'User disconnected');
        ws = null;
      }
    }

    function sendCommand() {
      if (!ws || ws.readyState !== WebSocket.OPEN) {
        logMessage('error', 'WebSocket is not connected');
        return;
      }
      const type = commandTypeSelect.value;
      const instanceId = commandInstanceIdInput.value.trim();
      const dataStr = commandDataTextarea.value.trim();

      const message = { type };

      // Instance id as payload
      if (instanceId) {
        message.instance_id = instanceId;
      }

      if (['create', 'update'].includes(type)) {
        let data = {};
        if (type === 'create' && imageFileInput.dataset.base64) {
          data.image_base64 = imageFileInput.dataset.base64;
          logMessage('info', `Using uploaded file: ${imageFileInput.files[0]?.name || 'unknown'}`);
        }
        if (dataStr) {
          try {
            const jsonData = JSON.parse(dataStr);
            data = { ...data, ...jsonData };
          } catch (e) {
            logMessage('error', 'Invalid JSON in data field', e.message);
            return;
          }
        }
        message.data = data;
      }

      try {
        const logMessage_data = { ...message };
        if (logMessage_data.data && logMessage_data.data.image_base64) {
          logMessage_data.data = {
            ...logMessage_data.data,
            image_base64: `[base64 data: ${logMessage_data.data.image_base64.length} chars]`
          };
        }
        logMessage('sent', `Command: ${type}`, logMessage_data);
        ws.send(JSON.stringify(message));
      } catch (error) {
        logMessage('error', 'Failed to send message', error);
      }
    }

    // Preset functions
    function loadPreset(preset) {
      imageFileInput.value = '';
      imageFileInput.dataset.base64 = '';
      fileInfo.textContent = '';
      switch (preset) {
        case 'subscribe':
          commandTypeSelect.value = 'subscribe';
          commandTypeSelect.dispatchEvent(new Event('change'));
          break;
        case 'list':
          commandTypeSelect.value = 'list';
          commandTypeSelect.dispatchEvent(new Event('change'));
          break;
        case 'create':
          commandTypeSelect.value = 'create';
          commandDataTextarea.value = '';
          commandTypeSelect.dispatchEvent(new Event('change'));
          break;
        case 'update':
          commandTypeSelect.value = 'update';
          commandDataTextarea.value = JSON.stringify({
            status: 'processed',
            processed_text: 'Sample processed text'
          }, null, 2);
          commandTypeSelect.dispatchEvent(new Event('change'));
          break;
      }
    }

    connectBtn.addEventListener('click', connect);
    disconnectBtn.addEventListener('click', disconnect);
    sendBtn.addEventListener('click', sendCommand);

    clearLogBtn.addEventListener('click', () => {
      messageLog.innerHTML = '';
      messageHistory = [];
      stats = { sent: 0, received: 0, errors: 0 };
      updateStats();
    });

    exportLogBtn.addEventListener('click', () => {
      const logData = {
        timestamp: new Date().toISOString(),
        stats,
        messages: messageHistory
      };
      const blob = new Blob([JSON.stringify(logData, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `websocket-log-${Date.now()}.json`;
      a.click();
      URL.revokeObjectURL(url);
    });

    commandDataTextarea.addEventListener('keydown', (e) => {
      if (e.ctrlKey && e.key === 'Enter') {
        // Never let ctrl+enter cause form submit/page reload
        e.preventDefault();
        sendCommand();
      }
    });

    // Prevent form submit anywhere (in case the page is inside a form for any reason)
    document.addEventListener('submit', function(e) {
      e.preventDefault();
      return false;
    }, true);

    updateStats();
  </script>
</body>
</html>